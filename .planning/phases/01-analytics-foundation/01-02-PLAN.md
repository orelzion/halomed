---
phase: 01-analytics-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - supabase/migrations/202601XX_create_analytics_views.sql
autonomous: true

must_haves:
  truths:
    - "System can query active learning days per user (completed units only)"
    - "System can query popular tracks with completion rates"
    - "System can identify streak drop-off points (where users lose momentum)"
    - "System can query quiz completion rates by week"
    - "Only admins can access these analytics views"
  artifacts:
    - path: "supabase/migrations/20260128100004_create_core_analytics_views.sql"
      provides: "Core analytics materialized views"
      contains: "CREATE MATERIALIZED VIEW analytics."
    - path: "supabase/migrations/20260128100005_create_analytics_rls_policies.sql"
      provides: "RLS policies for analytics views"
      contains: "is_admin()"
  key_links:
    - from: "analytics.active_learning_days"
      to: "user_study_log"
      via: "aggregation query"
      pattern: "FROM user_study_log"
    - from: "analytics.popular_tracks"
      to: "tracks"
      via: "JOIN"
      pattern: "JOIN tracks"
    - from: "analytics.streak_dropoffs"
      to: "user_study_log"
      via: "window function analysis"
      pattern: "ROW_NUMBER.*OVER"
    - from: "analytics.quiz_completion_rates"
      to: "learning_path"
      via: "aggregation on quiz nodes"
      pattern: "node_type.*quiz"
---

<objective>
Create core analytics materialized views for engagement metrics.

Purpose: Implements the primary analytics metrics (Active Learning Days, Popular Tracks, Streak Drop-offs, Quiz Completion) as PostgreSQL materialized views. These pre-computed aggregations enable fast admin queries without impacting application performance.

Output: Two SQL migrations creating 4 materialized views with RLS policies restricting access to admins only.
</objective>

<execution_context>
@/Users/orelzion/.claude/get-shit-done/workflows/execute-plan.md
@/Users/orelzion/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-analytics-foundation/01-01-SUMMARY.md

# Source tables for analytics
@supabase/migrations/20260112173226_create_user_study_log_table.sql
@supabase/migrations/20260117221634_create_learning_path_table.sql
@supabase/migrations/20260112173132_create_tracks_table.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create core analytics materialized views</name>
  <files>
    supabase/migrations/20260128100004_create_core_analytics_views.sql
  </files>
  <action>
Create SQL migration with 4 materialized views in the analytics schema.

**1. Active Learning Days (ANLYT-01)**
```sql
CREATE MATERIALIZED VIEW analytics.active_learning_days AS
SELECT
  user_id,
  COUNT(DISTINCT study_date) as total_active_days,
  COUNT(DISTINCT study_date) FILTER (WHERE study_date >= CURRENT_DATE - INTERVAL '7 days') as active_days_7d,
  COUNT(DISTINCT study_date) FILTER (WHERE study_date >= CURRENT_DATE - INTERVAL '30 days') as active_days_30d,
  MIN(study_date) as first_active_date,
  MAX(study_date) as last_active_date
FROM user_study_log
WHERE is_completed = TRUE
GROUP BY user_id;

CREATE UNIQUE INDEX idx_active_learning_days_user ON analytics.active_learning_days(user_id);
```

Note: user_study_log rows only exist for scheduled days (weekdays when content available), so counting completed rows automatically excludes Shabbat/holidays per ANLYT-01.

**2. Popular Tracks (ANLYT-02)**
```sql
CREATE MATERIALIZED VIEW analytics.popular_tracks AS
SELECT
  t.id as track_id,
  t.title as track_title,
  COUNT(DISTINCT usl.user_id) as total_users,
  COUNT(*) FILTER (WHERE usl.is_completed) as total_completions,
  COUNT(*) as total_scheduled,
  ROUND(
    COUNT(*) FILTER (WHERE usl.is_completed)::NUMERIC /
    NULLIF(COUNT(*), 0) * 100,
    2
  ) as completion_rate_pct
FROM tracks t
LEFT JOIN user_study_log usl ON usl.track_id = t.id
GROUP BY t.id, t.title
ORDER BY total_users DESC;

CREATE UNIQUE INDEX idx_popular_tracks_id ON analytics.popular_tracks(track_id);
```

**3. Streak Drop-offs (ANLYT-03)**
Uses window functions to identify where users lose momentum:
```sql
CREATE MATERIALIZED VIEW analytics.streak_dropoffs AS
WITH numbered_dates AS (
  SELECT
    user_id,
    track_id,
    study_date,
    is_completed,
    ROW_NUMBER() OVER (PARTITION BY user_id, track_id ORDER BY study_date) as rn
  FROM user_study_log
  WHERE study_date >= CURRENT_DATE - INTERVAL '180 days'
),
streak_groups AS (
  SELECT
    user_id,
    track_id,
    study_date,
    (study_date - (rn * INTERVAL '1 day'))::date as streak_group
  FROM numbered_dates
  WHERE is_completed = TRUE
),
completed_streaks AS (
  SELECT
    user_id,
    track_id,
    streak_group,
    COUNT(*) as streak_length,
    MAX(study_date) as streak_end
  FROM streak_groups
  GROUP BY user_id, track_id, streak_group
)
SELECT
  streak_length as days_before_dropoff,
  COUNT(*) as num_streaks_ended,
  ROUND(COUNT(*)::NUMERIC / SUM(COUNT(*)) OVER () * 100, 2) as percentage
FROM completed_streaks
WHERE streak_end < CURRENT_DATE - INTERVAL '7 days'
GROUP BY streak_length
ORDER BY streak_length;

CREATE INDEX idx_streak_dropoffs_days ON analytics.streak_dropoffs(days_before_dropoff);
```

**4. Quiz Completion Rates (ANLYT-04)**
```sql
CREATE MATERIALIZED VIEW analytics.quiz_completion_rates AS
SELECT
  DATE_TRUNC('week', unlock_date)::date as week_start,
  COUNT(DISTINCT user_id) as users_with_quizzes,
  COUNT(*) as total_quizzes,
  COUNT(*) FILTER (WHERE completed_at IS NOT NULL) as completed_quizzes,
  ROUND(
    COUNT(*) FILTER (WHERE completed_at IS NOT NULL)::NUMERIC /
    NULLIF(COUNT(*), 0) * 100,
    2
  ) as completion_rate_pct
FROM learning_path
WHERE node_type = 'quiz'
  AND unlock_date >= CURRENT_DATE - INTERVAL '90 days'
GROUP BY DATE_TRUNC('week', unlock_date)
ORDER BY week_start DESC;

CREATE UNIQUE INDEX idx_quiz_rates_week ON analytics.quiz_completion_rates(week_start);
```

Add comments to each view explaining:
- What metric it tracks
- Which requirement it addresses (ANLYT-XX)
- Data freshness expectations (refreshed via pg_cron)
  </action>
  <verify>
After applying migration:
```sql
-- Verify views exist
SELECT matviewname FROM pg_matviews WHERE schemaname = 'analytics';

-- Verify indexes
SELECT indexname FROM pg_indexes WHERE schemaname = 'analytics';

-- Test queries (will return empty if no data)
SELECT * FROM analytics.active_learning_days LIMIT 5;
SELECT * FROM analytics.popular_tracks LIMIT 5;
```
  </verify>
  <done>
- 4 materialized views created in analytics schema
- Each view has appropriate unique index for CONCURRENT refresh
- Views aggregate from user_study_log, learning_path, tracks tables
  </done>
</task>

<task type="auto">
  <name>Task 2: Create RLS policies for analytics views</name>
  <files>
    supabase/migrations/20260128100005_create_analytics_rls_policies.sql
  </files>
  <action>
Create SQL migration that enables RLS on analytics materialized views and restricts access to admins.

**Enable RLS and create policies:**

For each materialized view, PostgreSQL doesn't support RLS directly on materialized views. Instead, create wrapper functions that check admin status:

```sql
-- Analytics query functions that enforce admin access
-- These wrap the materialized views with role checking

CREATE OR REPLACE FUNCTION analytics.get_active_learning_days()
RETURNS SETOF analytics.active_learning_days AS $$
BEGIN
  IF NOT public.is_admin() THEN
    RAISE EXCEPTION 'Access denied: Admin role required';
  END IF;
  RETURN QUERY SELECT * FROM analytics.active_learning_days;
END;
$$ LANGUAGE plpgsql STABLE SECURITY DEFINER;

CREATE OR REPLACE FUNCTION analytics.get_popular_tracks()
RETURNS SETOF analytics.popular_tracks AS $$
BEGIN
  IF NOT public.is_admin() THEN
    RAISE EXCEPTION 'Access denied: Admin role required';
  END IF;
  RETURN QUERY SELECT * FROM analytics.popular_tracks;
END;
$$ LANGUAGE plpgsql STABLE SECURITY DEFINER;

CREATE OR REPLACE FUNCTION analytics.get_streak_dropoffs()
RETURNS SETOF analytics.streak_dropoffs AS $$
BEGIN
  IF NOT public.is_admin() THEN
    RAISE EXCEPTION 'Access denied: Admin role required';
  END IF;
  RETURN QUERY SELECT * FROM analytics.streak_dropoffs;
END;
$$ LANGUAGE plpgsql STABLE SECURITY DEFINER;

CREATE OR REPLACE FUNCTION analytics.get_quiz_completion_rates()
RETURNS SETOF analytics.quiz_completion_rates AS $$
BEGIN
  IF NOT public.is_admin() THEN
    RAISE EXCEPTION 'Access denied: Admin role required';
  END IF;
  RETURN QUERY SELECT * FROM analytics.quiz_completion_rates;
END;
$$ LANGUAGE plpgsql STABLE SECURITY DEFINER;

-- Grant execute to authenticated users (admin check happens inside)
GRANT USAGE ON SCHEMA analytics TO authenticated;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA analytics TO authenticated;
```

Additionally, revoke direct SELECT on the materialized views from authenticated role:
```sql
-- Revoke direct access to views (force use of functions)
REVOKE ALL ON ALL TABLES IN SCHEMA analytics FROM authenticated;
REVOKE ALL ON ALL TABLES IN SCHEMA analytics FROM anon;
```

Add comment explaining:
- Materialized views don't support RLS natively
- Wrapper functions enforce admin check
- Direct table access is revoked
  </action>
  <verify>
```sql
-- Verify functions exist
SELECT routine_name FROM information_schema.routines
WHERE routine_schema = 'analytics' AND routine_type = 'FUNCTION';

-- Test access denial for non-admin (should error)
-- This requires a test user without admin role
SET LOCAL jwt.claims.user_role = 'user';
SELECT * FROM analytics.get_active_learning_days(); -- Should raise exception

-- Test admin access works
SET LOCAL jwt.claims.user_role = 'admin';
SELECT * FROM analytics.get_active_learning_days(); -- Should work
```
  </verify>
  <done>
- Wrapper functions created for each materialized view
- Functions check is_admin() before returning data
- Direct table access revoked from authenticated/anon roles
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Verify materialized views exist:**
   ```sql
   SELECT matviewname FROM pg_matviews WHERE schemaname = 'analytics';
   -- Should return: active_learning_days, popular_tracks, streak_dropoffs, quiz_completion_rates
   ```

2. **Verify wrapper functions exist:**
   ```sql
   SELECT routine_name FROM information_schema.routines WHERE routine_schema = 'analytics';
   -- Should return: get_active_learning_days, get_popular_tracks, get_streak_dropoffs, get_quiz_completion_rates
   ```

3. **Test with sample data (if available):**
   ```sql
   -- Seed test admin
   INSERT INTO user_roles (user_id, role) VALUES ('your-test-user-id', 'admin');

   -- Query via function
   SELECT * FROM analytics.get_popular_tracks();
   ```
</verification>

<success_criteria>
- Four materialized views created in analytics schema
- Each view has unique index for CONCURRENT refresh
- Wrapper functions enforce admin-only access
- Direct table access revoked
- `supabase db push` applies without errors
</success_criteria>

<output>
After completion, create `.planning/phases/01-analytics-foundation/01-02-SUMMARY.md`
</output>
