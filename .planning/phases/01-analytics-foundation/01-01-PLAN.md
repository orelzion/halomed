---
phase: 01-analytics-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/202601XX_create_analytics_schema.sql
  - supabase/migrations/202601XX_create_user_roles_table.sql
  - supabase/migrations/202601XX_create_admin_auth_hook.sql
autonomous: true

must_haves:
  truths:
    - "Admin role can be assigned to specific users in database"
    - "JWT tokens contain user_role claim for authenticated users"
    - "Analytics schema exists separate from public schema"
    - "RLS policies prevent non-admin access to analytics schema"
  artifacts:
    - path: "supabase/migrations/202601XX_create_analytics_schema.sql"
      provides: "Analytics schema creation"
      contains: "CREATE SCHEMA analytics"
    - path: "supabase/migrations/202601XX_create_user_roles_table.sql"
      provides: "User roles table with admin enum"
      contains: "CREATE TABLE user_roles"
    - path: "supabase/migrations/202601XX_create_admin_auth_hook.sql"
      provides: "Auth hook for JWT custom claims"
      contains: "custom_access_token_hook"
  key_links:
    - from: "auth.users"
      to: "user_roles"
      via: "foreign key on user_id"
      pattern: "REFERENCES auth.users"
    - from: "custom_access_token_hook"
      to: "user_roles"
      via: "SELECT role lookup"
      pattern: "FROM.*user_roles"
---

<objective>
Create admin role infrastructure for analytics access control.

Purpose: Establishes the foundation for admin-only analytics by creating the user_roles table, analytics schema, and Auth Hook that injects user_role into JWT tokens. This enables RLS policies to check admin status without per-row subqueries.

Output: Three SQL migrations that create the admin role infrastructure, ready for analytics views to build upon.
</objective>

<execution_context>
@/Users/orelzion/.claude/get-shit-done/workflows/execute-plan.md
@/Users/orelzion/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Existing migrations for reference
@supabase/migrations/20260112173226_create_user_study_log_table.sql
@supabase/migrations/20260117221634_create_learning_path_table.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create analytics schema and user_roles table</name>
  <files>
    supabase/migrations/20260128100000_create_analytics_schema.sql
    supabase/migrations/20260128100001_create_user_roles_table.sql
  </files>
  <action>
Create two SQL migration files:

**Migration 1: Analytics Schema** (`20260128100000_create_analytics_schema.sql`)
- Create `analytics` schema separate from `public`
- Add comment documenting it's for admin-only aggregated metrics
- Do NOT add to realtime publication (keeps it server-side only per ANLYT-13)

**Migration 2: User Roles Table** (`20260128100001_create_user_roles_table.sql`)
- Create enum type `app_role` with values ('user', 'admin')
- Create `user_roles` table in public schema with:
  - `user_id` UUID primary key, references auth.users(id) ON DELETE CASCADE
  - `role` app_role with default 'user'
  - `created_at` TIMESTAMPTZ default NOW()
  - `updated_at` TIMESTAMPTZ default NOW()
- Create trigger for updated_at (reuse pattern from existing migrations)
- Enable RLS on user_roles table
- Create RLS policies:
  - Admins can SELECT all rows
  - Admins can INSERT/UPDATE rows
  - Users can SELECT their own row only (to check own role)
- Add comments documenting purpose

Reference pattern from research:
```sql
CREATE TYPE app_role AS ENUM ('user', 'admin');
CREATE TABLE user_roles (
  user_id UUID REFERENCES auth.users(id) PRIMARY KEY,
  role app_role DEFAULT 'user'
);
```
  </action>
  <verify>
Run `supabase db push` or `supabase migration up` to apply migrations locally. Verify with:
```sql
SELECT schema_name FROM information_schema.schemata WHERE schema_name = 'analytics';
SELECT * FROM pg_type WHERE typname = 'app_role';
\d user_roles
```
  </verify>
  <done>
- Analytics schema exists
- app_role enum has 'user' and 'admin' values
- user_roles table exists with proper constraints and RLS
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Auth Hook for JWT custom claims</name>
  <files>
    supabase/migrations/20260128100002_create_admin_auth_hook.sql
  </files>
  <action>
Create SQL migration that defines the Auth Hook function for injecting user_role into JWT tokens.

**Migration: Auth Hook** (`20260128100002_create_admin_auth_hook.sql`)

Create function `public.custom_access_token_hook(event jsonb) RETURNS jsonb`:
- Mark as LANGUAGE plpgsql STABLE SECURITY DEFINER
- Query user_roles table for user's role: `SELECT role::text FROM user_roles WHERE user_id = (event->>'user_id')::uuid`
- Inject role into JWT claims: `event := jsonb_set(event, '{claims,user_role}', to_jsonb(COALESCE(user_role, 'user')))`
- Return modified event

Grant execute permission to supabase_auth_admin role (required for Auth Hooks).

Add SQL comment explaining:
- This function is called by Supabase Auth when issuing tokens
- Must be registered in Supabase Dashboard > Auth > Hooks after deployment
- The user_role claim enables RLS policies to check admin status efficiently

Reference pattern from research:
```sql
CREATE OR REPLACE FUNCTION public.custom_access_token_hook(event jsonb)
RETURNS jsonb AS $$
DECLARE
  user_role text;
BEGIN
  SELECT role::text INTO user_role
  FROM public.user_roles
  WHERE user_id = (event->>'user_id')::uuid;

  event := jsonb_set(event, '{claims,user_role}', to_jsonb(COALESCE(user_role, 'user')));
  RETURN event;
END;
$$ LANGUAGE plpgsql STABLE SECURITY DEFINER;

GRANT EXECUTE ON FUNCTION public.custom_access_token_hook TO supabase_auth_admin;
```

IMPORTANT: Do NOT use SET search_path in the function - this can cause issues with Supabase Auth Hooks.
  </action>
  <verify>
After applying migration:
```sql
SELECT proname, prosrc FROM pg_proc WHERE proname = 'custom_access_token_hook';
SELECT has_function_privilege('supabase_auth_admin', 'custom_access_token_hook(jsonb)', 'execute');
```
  </verify>
  <done>
- custom_access_token_hook function exists
- Function is granted to supabase_auth_admin
- Function queries user_roles and injects user_role claim
  </done>
</task>

<task type="auto">
  <name>Task 3: Create helper function for RLS admin checks</name>
  <files>
    supabase/migrations/20260128100003_create_admin_check_function.sql
  </files>
  <action>
Create SQL migration for a helper function that efficiently checks admin status in RLS policies.

**Migration: Admin Check Function** (`20260128100003_create_admin_check_function.sql`)

Create function `public.is_admin() RETURNS boolean`:
- Mark as LANGUAGE sql STABLE (allows query plan caching)
- Use wrapped SELECT pattern to avoid per-row evaluation:
  ```sql
  SELECT (SELECT (auth.jwt() ->> 'user_role')) = 'admin'
  ```
- Return false if user_role claim is null or not 'admin'

Add comment explaining this function is used in RLS policies to check admin status efficiently.

Reference from research pitfall section: "Wrap auth functions in SELECT" to enable caching and avoid RLS performance death spiral.
  </action>
  <verify>
After applying migration:
```sql
SELECT proname FROM pg_proc WHERE proname = 'is_admin';
-- Test the function (will return false for anon/non-admin):
SELECT public.is_admin();
```
  </verify>
  <done>
- is_admin() function exists
- Function uses STABLE qualifier for caching
- Function properly checks JWT user_role claim
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Schema check:**
   ```bash
   supabase db reset  # Apply all migrations fresh
   ```

2. **Verify structures exist:**
   ```sql
   -- Analytics schema
   SELECT schema_name FROM information_schema.schemata WHERE schema_name = 'analytics';

   -- User roles table
   SELECT column_name, data_type FROM information_schema.columns WHERE table_name = 'user_roles';

   -- Auth hook function
   SELECT proname FROM pg_proc WHERE proname = 'custom_access_token_hook';

   -- Admin check function
   SELECT proname FROM pg_proc WHERE proname = 'is_admin';
   ```

3. **RLS enabled:**
   ```sql
   SELECT relname, relrowsecurity FROM pg_class WHERE relname = 'user_roles';
   ```
</verification>

<success_criteria>
- Four SQL migrations created and syntactically valid
- `supabase db push` applies without errors
- Analytics schema exists (separate from public)
- user_roles table has RLS enabled with admin/user policies
- custom_access_token_hook function exists with proper grants
- is_admin() helper function ready for RLS policies
</success_criteria>

<output>
After completion, create `.planning/phases/01-analytics-foundation/01-01-SUMMARY.md`
</output>
