---
phase: 01-analytics-foundation
plan: 04
type: execute
wave: 3
depends_on: ["01-02", "01-03"]
files_modified:
  - supabase/migrations/202601XX_create_analytics_cron.sql
autonomous: true
user_setup:
  - service: supabase
    why: "Auth Hook must be registered in Supabase Dashboard"
    dashboard_config:
      - task: "Register custom_access_token_hook in Auth > Hooks"
        location: "Supabase Dashboard > Authentication > Hooks > Add Hook"

must_haves:
  truths:
    - "Materialized views refresh automatically on schedule"
    - "Admin can manually trigger refresh if needed"
    - "Cron job runs without errors"
  artifacts:
    - path: "supabase/migrations/20260128100008_create_analytics_cron.sql"
      provides: "pg_cron job for view refresh"
      contains: "cron.schedule"
  key_links:
    - from: "cron.schedule"
      to: "analytics.*"
      via: "REFRESH MATERIALIZED VIEW"
      pattern: "REFRESH MATERIALIZED VIEW CONCURRENTLY"
---

<objective>
Create scheduled refresh for analytics materialized views using pg_cron.

Purpose: Implements automatic refresh of all analytics materialized views every 30 minutes. This ensures analytics data stays reasonably current without impacting application performance or requiring manual intervention.

Output: SQL migration creating pg_cron job and manual refresh function.
</objective>

<execution_context>
@/Users/orelzion/.claude/get-shit-done/workflows/execute-plan.md
@/Users/orelzion/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-analytics-foundation/01-02-SUMMARY.md
@.planning/phases/01-analytics-foundation/01-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create pg_cron job for materialized view refresh</name>
  <files>
    supabase/migrations/20260128100008_create_analytics_cron.sql
  </files>
  <action>
Create SQL migration that schedules automatic refresh of all analytics materialized views.

**1. Enable pg_cron extension (if not already enabled):**
```sql
-- pg_cron is enabled by default in Supabase, but ensure it's available
CREATE EXTENSION IF NOT EXISTS pg_cron;
```

**2. Create refresh function:**
```sql
-- Function to refresh all analytics views
-- Can be called manually or via cron
CREATE OR REPLACE FUNCTION analytics.refresh_all_views()
RETURNS void AS $$
BEGIN
  -- Refresh in dependency order (base views first)
  REFRESH MATERIALIZED VIEW CONCURRENTLY analytics.active_learning_days;
  REFRESH MATERIALIZED VIEW CONCURRENTLY analytics.popular_tracks;
  REFRESH MATERIALIZED VIEW CONCURRENTLY analytics.streak_dropoffs;
  REFRESH MATERIALIZED VIEW CONCURRENTLY analytics.quiz_completion_rates;
  REFRESH MATERIALIZED VIEW CONCURRENTLY analytics.review_session_usage;
  REFRESH MATERIALIZED VIEW CONCURRENTLY analytics.explanation_engagement;
  -- Summary stats last (depends on no other views but good to be fresh)
  REFRESH MATERIALIZED VIEW CONCURRENTLY analytics.summary_stats;

  RAISE NOTICE 'Analytics views refreshed at %', NOW();
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

COMMENT ON FUNCTION analytics.refresh_all_views IS
  'Refreshes all analytics materialized views. Called by pg_cron every 30 minutes.';
```

**3. Schedule cron job:**
```sql
-- Schedule refresh every 30 minutes
-- Supabase pg_cron runs in UTC timezone
SELECT cron.schedule(
  'refresh-analytics-views',      -- job name
  '*/30 * * * *',                 -- every 30 minutes
  'SELECT analytics.refresh_all_views()'
);

COMMENT ON FUNCTION analytics.refresh_all_views IS
  'Refreshes all analytics materialized views. Scheduled via pg_cron every 30 minutes (job: refresh-analytics-views).';
```

**4. Create manual refresh function for admins:**
```sql
-- Admin-accessible manual refresh
CREATE OR REPLACE FUNCTION analytics.manual_refresh()
RETURNS TEXT AS $$
BEGIN
  IF NOT public.is_admin() THEN
    RAISE EXCEPTION 'Access denied: Admin role required';
  END IF;

  PERFORM analytics.refresh_all_views();
  RETURN 'Analytics views refreshed at ' || NOW()::TEXT;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

GRANT EXECUTE ON FUNCTION analytics.manual_refresh TO authenticated;

COMMENT ON FUNCTION analytics.manual_refresh IS
  'Allows admins to manually trigger analytics view refresh. Rate limit in application layer.';
```

**5. Add cron job monitoring view:**
```sql
-- View for monitoring cron job execution (admin only)
CREATE OR REPLACE VIEW analytics.cron_job_status AS
SELECT
  jobid,
  jobname,
  schedule,
  command,
  (SELECT MAX(start_time) FROM cron.job_run_details WHERE jobid = cron.job.jobid) as last_run,
  (SELECT status FROM cron.job_run_details WHERE jobid = cron.job.jobid ORDER BY start_time DESC LIMIT 1) as last_status
FROM cron.job
WHERE jobname = 'refresh-analytics-views';

-- Wrapper function for admin access
CREATE OR REPLACE FUNCTION analytics.get_cron_job_status()
RETURNS TABLE(
  jobid bigint,
  jobname text,
  schedule text,
  command text,
  last_run timestamp with time zone,
  last_status text
) AS $$
BEGIN
  IF NOT public.is_admin() THEN
    RAISE EXCEPTION 'Access denied: Admin role required';
  END IF;
  RETURN QUERY SELECT * FROM analytics.cron_job_status;
END;
$$ LANGUAGE plpgsql STABLE SECURITY DEFINER;

GRANT EXECUTE ON FUNCTION analytics.get_cron_job_status TO authenticated;
```
  </action>
  <verify>
After applying migration:
```sql
-- Verify cron job is scheduled
SELECT * FROM cron.job WHERE jobname = 'refresh-analytics-views';

-- Verify refresh function exists
SELECT proname FROM pg_proc WHERE proname = 'refresh_all_views' AND pronamespace = (SELECT oid FROM pg_namespace WHERE nspname = 'analytics');

-- Test manual refresh (as admin)
SELECT analytics.manual_refresh();

-- Check job run history (may be empty initially)
SELECT * FROM cron.job_run_details WHERE jobname = 'refresh-analytics-views' ORDER BY start_time DESC LIMIT 5;
```
  </verify>
  <done>
- pg_cron job 'refresh-analytics-views' scheduled for every 30 minutes
- refresh_all_views() function refreshes all 7 materialized views
- manual_refresh() allows admin-triggered refresh
- Cron job monitoring available via get_cron_job_status()
  </done>
</task>

<task type="auto">
  <name>Task 2: Add initial view population and verification</name>
  <files>
    supabase/migrations/20260128100009_populate_analytics_views.sql
  </files>
  <action>
Create SQL migration that performs initial population of all analytics views and verifies the setup.

**1. Initial refresh of all views:**
```sql
-- Perform initial refresh of all analytics views
-- This populates them with current data
DO $$
BEGIN
  -- Refresh each view (not CONCURRENTLY for initial population since views may be empty)
  REFRESH MATERIALIZED VIEW analytics.active_learning_days;
  REFRESH MATERIALIZED VIEW analytics.popular_tracks;
  REFRESH MATERIALIZED VIEW analytics.streak_dropoffs;
  REFRESH MATERIALIZED VIEW analytics.quiz_completion_rates;
  REFRESH MATERIALIZED VIEW analytics.review_session_usage;
  REFRESH MATERIALIZED VIEW analytics.explanation_engagement;
  REFRESH MATERIALIZED VIEW analytics.summary_stats;

  RAISE NOTICE 'Initial analytics view population complete at %', NOW();
END $$;
```

**2. Verify cron extension is properly configured:**
```sql
-- Verify pg_cron is working
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_extension WHERE extname = 'pg_cron') THEN
    RAISE EXCEPTION 'pg_cron extension not found. Enable in Supabase Dashboard > Database > Extensions';
  END IF;

  IF NOT EXISTS (SELECT 1 FROM cron.job WHERE jobname = 'refresh-analytics-views') THEN
    RAISE WARNING 'Cron job not found. May need to run migration 20260128100008 first.';
  END IF;
END $$;
```

**3. Add health check function:**
```sql
-- Analytics health check for monitoring
CREATE OR REPLACE FUNCTION analytics.health_check()
RETURNS TABLE(
  view_name text,
  row_count bigint,
  last_refresh timestamp with time zone
) AS $$
BEGIN
  IF NOT public.is_admin() THEN
    RAISE EXCEPTION 'Access denied: Admin role required';
  END IF;

  RETURN QUERY
  SELECT 'active_learning_days'::text, COUNT(*)::bigint, NULL::timestamptz FROM analytics.active_learning_days
  UNION ALL
  SELECT 'popular_tracks', COUNT(*), NULL FROM analytics.popular_tracks
  UNION ALL
  SELECT 'streak_dropoffs', COUNT(*), NULL FROM analytics.streak_dropoffs
  UNION ALL
  SELECT 'quiz_completion_rates', COUNT(*), NULL FROM analytics.quiz_completion_rates
  UNION ALL
  SELECT 'review_session_usage', COUNT(*), NULL FROM analytics.review_session_usage
  UNION ALL
  SELECT 'explanation_engagement', COUNT(*), NULL FROM analytics.explanation_engagement
  UNION ALL
  SELECT 'summary_stats', COUNT(*), refreshed_at FROM analytics.summary_stats;
END;
$$ LANGUAGE plpgsql STABLE SECURITY DEFINER;

GRANT EXECUTE ON FUNCTION analytics.health_check TO authenticated;

COMMENT ON FUNCTION analytics.health_check IS
  'Returns row counts and freshness for all analytics views. Useful for monitoring.';
```
  </action>
  <verify>
```sql
-- Run health check to verify all views are populated
SELECT * FROM analytics.health_check();

-- Verify cron job exists and is scheduled
SELECT jobname, schedule FROM cron.job WHERE jobname = 'refresh-analytics-views';

-- Check summary stats has refreshed_at timestamp
SELECT refreshed_at FROM analytics.summary_stats;
```
  </verify>
  <done>
- All analytics views initially populated
- health_check() function provides view status
- Cron job verified as scheduled
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Verify cron job is running:**
   ```sql
   SELECT * FROM cron.job WHERE jobname = 'refresh-analytics-views';
   ```

2. **Run health check:**
   ```sql
   -- As admin
   SELECT * FROM analytics.health_check();
   ```

3. **Test manual refresh:**
   ```sql
   SELECT analytics.manual_refresh();
   ```

4. **Verify all functions exist:**
   ```sql
   SELECT routine_name FROM information_schema.routines
   WHERE routine_schema = 'analytics'
   ORDER BY routine_name;
   ```
   Should list: get_active_learning_days, get_cron_job_status, get_explanation_engagement, get_popular_tracks, get_quiz_completion_rates, get_review_session_usage, get_streak_dropoffs, get_summary_stats, health_check, manual_refresh, refresh_all_views
</verification>

<success_criteria>
- pg_cron job scheduled for every 30 minutes
- All materialized views initially populated
- Manual refresh function works for admins
- Health check function provides view status
- `supabase db push` applies without errors
</success_criteria>

<output>
After completion, create `.planning/phases/01-analytics-foundation/01-04-SUMMARY.md`

NOTE: After execution, user must register the Auth Hook in Supabase Dashboard:
1. Go to Supabase Dashboard > Authentication > Hooks
2. Add new hook for "custom_access_token" event
3. Select the "custom_access_token_hook" function
4. Enable the hook
</output>
