---
description: Avoid code smells like arbitrary delays and polling
alwaysApply: true
---

# Avoid Code Smells

## No Arbitrary Delays

Never use `setTimeout` or arbitrary delays to "wait for something to be ready". This is always a sign of incorrect architecture.

```typescript
// ❌ BAD - arbitrary delay hoping data is ready
setTimeout(() => {
  doSomething();
}, 500);

// ❌ BAD - polling with timeouts
const checkAndRetry = () => {
  if (!ready) {
    setTimeout(checkAndRetry, 50);
  }
};

// ✅ GOOD - react to state changes
useEffect(() => {
  if (data && isReady) {
    doSomething();
  }
}, [data, isReady]);

// ✅ GOOD - use reactive queries/subscriptions
const subscription = query.subscribe((result) => {
  handleResult(result);
});
```

## Proper Solutions

1. **Use reactive state**: Let effects re-run when dependencies change
2. **Use subscriptions**: Subscribe to data changes instead of polling
3. **Use refs for DOM timing**: `requestAnimationFrame` for DOM readiness only
4. **Use proper async/await**: Chain promises correctly instead of arbitrary waits

## When Delays Are Acceptable

- Animation timing (CSS transitions, explicit animations)
- Debouncing user input
- Rate limiting API calls
- Explicit UX delays (e.g., showing a toast for 3 seconds)
